import React, { useState, useEffect, useRef } from 'react';
import { supabase, isSupabaseConfigured } from '../lib/supabase';
import ReviewCard from './ReviewCard';
import { trackTimeout, trackError } from '../utils/errorTracker';

const ReviewList = ({ placeId, newReview }) => {
  const [reviews, setReviews] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Track if component is initializing (first mount after refresh)
  const isInitializingRef = useRef(true);

  // Load reviews - ALWAYS FETCH FRESH (no cache)
  // Re-fetch on: placeId change, component mount
  // NOTE: visibilitychange dihapus karena terlalu agresif dan menyebabkan review hilang
  // Request deduplication - prevent multiple simultaneous requests
  // Use ref instead of state to avoid race conditions
  const pendingRequestRef = useRef(false);
  const abortControllerRef = useRef(null);
  const lastFetchTimeRef = useRef(0);
  const reviewsLengthRef = useRef(0);
  
  // Force refresh mechanism - increment untuk trigger re-fetch
  const [refreshTrigger, setRefreshTrigger] = useState(0);
  
  // Update reviewsLengthRef whenever reviews change
  useEffect(() => {
    reviewsLengthRef.current = reviews.length;
  }, [reviews.length]);
  
  // Real-time subscription untuk auto-update saat ada perubahan di Supabase
  useEffect(() => {
    if (!isSupabaseConfigured || !supabase || !placeId) return;
    
    console.log('[ReviewList] Setting up real-time subscriptions for place_id:', placeId);
    
    // Subscribe to changes in reviews table
    const reviewsChannel = supabase
      .channel(`reviews:${placeId}`)
      .on(
        'postgres_changes',
        {
          event: '*', // Listen to all events (INSERT, UPDATE, DELETE)
          schema: 'public',
          table: 'reviews',
          filter: `place_id=eq.${placeId}`
        },
        (payload) => {
          console.log('[ReviewList] üîî Real-time review update:', payload.eventType, payload.new?.id || payload.old?.id);
          
          // Handle different event types
          if (payload.eventType === 'INSERT' && payload.new) {
            // New review added - optimistic update + smart refetch
            console.log('[ReviewList] New review detected via real-time');
            setTimeout(() => {
              pendingRequestRef.current = false;
              setRefreshTrigger(prev => prev + 1);
            }, 200); // Reduced delay untuk faster update
          } else if (payload.eventType === 'UPDATE' && payload.new) {
            // Review updated - update local state immediately
            console.log('[ReviewList] Review updated via real-time');
            setReviews(prev => prev.map(r => 
              r.id === payload.new.id ? { ...r, ...payload.new } : r
            ));
            // Optional: trigger refetch untuk sync
            setTimeout(() => {
              pendingRequestRef.current = false;
              setRefreshTrigger(prev => prev + 1);
            }, 200);
          } else if (payload.eventType === 'DELETE' && payload.old) {
            // Review deleted - remove from local state immediately
            console.log('[ReviewList] Review deleted via real-time');
            setReviews(prev => prev.filter(r => r.id !== payload.old.id));
          }
        }
      )
      .subscribe((status) => {
        console.log('[ReviewList] Reviews subscription status:', status);
      });
    
    // Subscribe to changes in review_replies table (untuk reply updates)
    // CRITICAL: Subscribe to replies untuk detect reply baru tanpa perlu refetch semua reviews
    const repliesChannel = supabase
      .channel(`replies:${placeId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'review_replies',
          // Filter by review_id yang ada di current reviews
          // Note: Supabase doesn't support complex filters, so we'll handle filtering in callback
        },
        (payload) => {
          console.log('[ReviewList] üîî Real-time reply update:', payload.eventType, payload.new?.review_id || payload.old?.review_id);
          
          // Update local state untuk reply yang baru ditambahkan/diupdate
          if (payload.eventType === 'INSERT' && payload.new) {
            // New reply added - update review yang sesuai
            setReviews(prev => prev.map(review => {
              if (review.id === payload.new.review_id) {
                // Add new reply to existing replies
                const updatedReplies = [...(review.replies || []), payload.new];
                return { ...review, replies: updatedReplies };
              }
              return review;
            }));
          } else if (payload.eventType === 'UPDATE' && payload.new) {
            // Reply updated - update reply di review
            setReviews(prev => prev.map(review => {
              if (review.id === payload.new.review_id) {
                const updatedReplies = (review.replies || []).map(reply =>
                  reply.id === payload.new.id ? payload.new : reply
                );
                return { ...review, replies: updatedReplies };
              }
              return review;
            }));
          } else if (payload.eventType === 'DELETE' && payload.old) {
            // Reply deleted - remove from review
            setReviews(prev => prev.map(review => {
              if (review.id === payload.old.review_id) {
                const updatedReplies = (review.replies || []).filter(reply => reply.id !== payload.old.id);
                return { ...review, replies: updatedReplies };
              }
              return review;
            }));
          }
        }
      )
      .subscribe((status) => {
        console.log('[ReviewList] Replies subscription status:', status);
      });
    
    // Cleanup subscriptions on unmount or placeId change
    return () => {
      console.log('[ReviewList] Cleaning up real-time subscriptions');
      if (supabase) {
        supabase.removeChannel(reviewsChannel);
        supabase.removeChannel(repliesChannel);
      }
    };
  }, [placeId]);
  
  // ============================================
  // MOVE loadReviews KELUAR dari useEffect untuk performance
  // Function ini dipanggil dari useEffect, tapi didefinisikan di luar
  // ============================================
  const loadReviews = async (preserveExisting = false, forceRefresh = false) => {
    // CRITICAL: Prevent duplicate requests
    if (pendingRequestRef.current && !forceRefresh) {
      console.log('[ReviewList] Request already in progress, skipping duplicate request');
      return;
    }
    if (!placeId) {
      console.warn('[ReviewList] No placeId provided');
      setLoading(false);
      return;
    }
    
    // SIMPLIFIED COOLDOWN: Only 500ms untuk prevent spam, no complex logic
    const now = Date.now();
    const timeSinceLastFetch = now - lastFetchTimeRef.current;
    const cooldownTime = 500; // 0.5 detik - cukup untuk prevent spam tapi tetap fast
    
    if (!forceRefresh && timeSinceLastFetch < cooldownTime) {
      console.log(`[ReviewList] Cooldown active (${timeSinceLastFetch}ms < ${cooldownTime}ms)`);
      return;
    }
    
    console.log('[ReviewList] üöÄ Fetching reviews for place_id:', placeId, 'Timestamp:', new Date().toISOString());
    
    // OPTIMISTIC UI: Only set loading if we don't have reviews yet
    if (reviewsLengthRef.current === 0) {
      setLoading(true);
    } else {
      console.log('[ReviewList] Background refresh - keeping existing reviews visible');
    }
    
    setError(null);
    pendingRequestRef.current = true;
    
    // Abort previous request if exists
    if (abortControllerRef.current) {
      try {
        abortControllerRef.current.abort();
      } catch (e) {
        console.warn('[ReviewList] Error aborting previous request:', e);
      }
    }
    abortControllerRef.current = new AbortController();

    try {
      const startTime = Date.now();
      
      // ============================================
      // STEP 1: DIRECT FETCH - No Promise wrapping!
      // ============================================
      console.log('[ReviewList] Step 1: Fetching main reviews...');
      const { data, error } = await supabase
        .from('reviews')
        .select('id, user_id, place_id, rating, text, created_at, updated_at')
        .eq('place_id', placeId)
        .order('created_at', { ascending: false })
        .limit(25)
        .abortSignal(abortControllerRef.current.signal);
      
      const queryDuration = Date.now() - startTime;
      console.log(`[ReviewList] ‚úÖ Main query completed in ${queryDuration}ms`);
      
      if (error) {
        console.error('[ReviewList] ‚ùå Supabase error:', error);
        setError('Gagal memuat reviews');
        if (!preserveExisting) setReviews([]);
        return;
      }
      
      if (!data || data.length === 0) {
        console.log('[ReviewList] No reviews found for place_id:', placeId);
        setReviews([]);
        return;
      }
      
      console.log(`[ReviewList] Found ${data.length} reviews`);
      
      // ============================================
      // STEP 2: Fetch related data in PARALLEL
      // ============================================
      const userIds = [...new Set(data.map(r => r.user_id))];
      const reviewIds = data.map(r => r.id);
      
      console.log('[ReviewList] Step 2: Fetching profiles, photos, replies in parallel...');
      const batchStartTime = Date.now();
      
      const [profilesResult, photosResult, repliesResult] = await Promise.all([
        supabase
          .from('profiles')
          .select('id, username, avatar_url, full_name')
          .in('id', userIds)
          .abortSignal(abortControllerRef.current.signal),
        
        supabase
          .from('review_photos')
          .select('id, review_id, photo_url')
          .in('review_id', reviewIds)
          .abortSignal(abortControllerRef.current.signal),
        
        supabase
          .from('review_replies')
          .select('id, review_id, user_id, text, created_at, profiles:user_id(username, avatar_url, full_name)')
          .in('review_id', reviewIds)
          .order('created_at', { ascending: true })
          .abortSignal(abortControllerRef.current.signal)
      ]);
      
      const batchDuration = Date.now() - batchStartTime;
      console.log(`[ReviewList] ‚úÖ Batch queries completed in ${batchDuration}ms`);
      
      // ============================================
      // STEP 3: Map results efficiently
      // ============================================
      const profilesMap = (profilesResult.data || []).reduce((acc, p) => {
        acc[p.id] = p;
        return acc;
      }, {});
      
      const photosMap = (photosResult.data || []).reduce((acc, p) => {
        if (!acc[p.review_id]) acc[p.review_id] = [];
        acc[p.review_id].push(p);
        return acc;
      }, {});
      
      const repliesMap = (repliesResult.data || []).reduce((acc, r) => {
        if (!acc[r.review_id]) acc[r.review_id] = [];
        acc[r.review_id].push(r);
        return acc;
      }, {});
      
      // ============================================
      // STEP 4: Combine all data
      // ============================================
      const mappedReviews = data.map(r => ({
        ...r,
        profiles: profilesMap[r.user_id] || null,
        photos: photosMap[r.id] || [],
        replies: repliesMap[r.id] || [],
        source: 'supabase'
      }));
      
      const totalDuration = Date.now() - startTime;
      console.log(`[ReviewList] ‚úÖ TOTAL fetch completed in ${totalDuration}ms - Setting ${mappedReviews.length} reviews to state`);
      
      setReviews(mappedReviews);
      
    } catch (err) {
      const errorMessage = err?.message || err?.toString() || 'Unknown error';
      console.error('[ReviewList] ‚ùå Exception during fetch:', {
        message: errorMessage,
        error: err,
        placeId: placeId
      });
      
      trackError(err, { placeId, action: 'loadReviews' });
      setError('Gagal memuat review');
      
      if (!preserveExisting) {
        setReviews([]);
      }
    } finally {
      pendingRequestRef.current = false;
      setLoading(false);
      lastFetchTimeRef.current = Date.now();
      abortControllerRef.current = null;
    }
  };
  
  // ============================================
  // useEffect: Trigger loadReviews on mount/change
  // ============================================
  useEffect(() => {
    if (!placeId) {
      console.warn('[ReviewList] No placeId, skipping load');
      setLoading(false);
      return;
    }
        setLoading(true);
      } else {
        // We have reviews - fetch in background without showing skeleton
        setLoading(false);
      }
      setError(null);
      
      // Only clear reviews on initial load or placeId change
      // Don't clear if we're just refreshing (preserve existing reviews)
      if (!preserveExisting) {
        setReviews([]);
        setLoading(true); // Only show skeleton if clearing reviews
      }

      // Mark request as pending and setup abort controller
      pendingRequestRef.current = true;
      
      // Cancel previous request if exists
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
      
      // Create new abort controller
      const abortController = new AbortController();
      abortControllerRef.current = abortController;

      try {
        let supabaseReviews = [];

        // Load from Supabase if configured
        if (isSupabaseConfigured && supabase) {
          try {
            // Force fresh fetch dengan cache-busting timestamp
            const cacheBuster = Date.now();
            console.log('[ReviewList] Fetching reviews from Supabase (fresh fetch, no cache):', placeId, 'Cache buster:', cacheBuster);
            
            // ULTRA-OPTIMIZED QUERY: Fetch reviews dengan optimasi maksimal
            // 1. Hanya fetch field yang diperlukan (minimal data)
            // 2. Tidak fetch replies di initial load (lazy load saat diperlukan)
            // 3. Limit lebih kecil untuk faster query
            // 4. Order by index untuk performa optimal
            // 5. Single query tanpa join untuk prevent timeout
            const createFetchPromise = () => {
              const startQueryTime = Date.now();
              console.log('[ReviewList] üöÄ Starting optimized query...');
              
              const query = supabase
                .from('reviews')
                .select(`
                  id,
                  user_id,
                  place_id,
                  rating,
                  text,
                  created_at,
                  updated_at
                `)
                .eq('place_id', placeId)
                .order('created_at', { ascending: false })
                .limit(25); // Reduced to 25 for faster query - load more if needed
              
              // Log query execution time
              const queryPromise = query.then(result => {
                const queryDuration = Date.now() - startQueryTime;
                console.log(`[ReviewList] ‚ö° Query executed in ${queryDuration}ms`);
                return result;
              });
              
              return queryPromise;
            };
            
            // Retry logic dengan exponential backoff
            // SIMPLIFIED: Remove complex Promise wrapping that causes blocking
            const maxRetries = 0; // NO RETRY - fail fast
            const baseTimeout = 30000; // 30 detik - lebih panjang untuk test
            let data = null;
            let fetchError = null;
            let lastAttemptError = null; // Track last error
            let timeoutId = null; // For timeout tracking
            
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
              // Check if request was aborted
              if (abortController.signal.aborted) {
                console.log('[ReviewList] Request aborted, stopping retry loop');
                break;
              }
              
              try {
                // CRITICAL: Execute Supabase query - createFetchPromise() returns query builder, not Promise
                // We need to actually execute it to get a Promise
                const fetchPromise = createFetchPromise();
                
                // Timeout promise dengan waktu yang lebih pendek (15 detik)
                const timeoutPromise = new Promise((_, reject) => {
                  timeoutId = setTimeout(() => {
                    timeoutId = null; // Clear reference
                    reject(new Error(`Supabase request timeout after ${baseTimeout / 1000} seconds`));
                  }, baseTimeout);
                });
                
                // Clear timeout if request is aborted
                abortController.signal.addEventListener('abort', () => {
                  if (timeoutId) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                  }
                });
                
                console.log(`[ReviewList] Attempt ${attempt + 1}/${maxRetries + 1} to fetch reviews...`);
                const startTime = Date.now();
                
                // CRITICAL: Ensure fetchPromise is actually a Promise
                // Supabase query builder returns a Promise-like object that can be awaited
                // But we need to ensure it's properly executed
                const fetchPromiseExecuted = Promise.resolve(fetchPromise).then(
                  (res) => {
                    // Clear timeout on success
                    if (timeoutId) {
                      clearTimeout(timeoutId);
                      timeoutId = null;
                    }
                    const duration = Date.now() - startTime;
                    console.log(`[ReviewList] ‚úÖ Fetch promise resolved in ${duration}ms`);
                    return res;
                  },
                  (err) => {
                    // Clear timeout on error
                    if (timeoutId) {
                      clearTimeout(timeoutId);
                      timeoutId = null;
                    }
                    const duration = Date.now() - startTime;
                    console.error(`[ReviewList] ‚ùå Fetch promise rejected after ${duration}ms:`, err);
                    throw err;
                  }
                );
                
                // CRITICAL: Use Promise.race with proper cleanup
                // This ensures timeout is properly handled
                const result = await Promise.race([
                  fetchPromiseExecuted,
                  timeoutPromise.then(
                    () => {
                      // This should never happen, but just in case
                      console.warn('[ReviewList] ‚ö†Ô∏è Timeout promise resolved (unexpected)');
                      throw new Error('Timeout promise resolved unexpectedly');
                    },
                    (err) => {
                      // Timeout occurred
                      const duration = Date.now() - startTime;
                      console.error(`[ReviewList] ‚è±Ô∏è Timeout after ${duration}ms (timeout was ${baseTimeout}ms)`);
                      throw err;
                    }
                  )
                ]);
                
                const fetchDuration = Date.now() - startTime;
                console.log(`[ReviewList] ‚úÖ Fetch completed successfully in ${fetchDuration}ms`);
                
                // Check if request was aborted
                if (abortController.signal.aborted) {
                  console.log('[ReviewList] Request aborted during fetch');
                  break;
                }
                
                // Check if result has error
                if (result.error) {
                  fetchError = result.error;
                  lastAttemptError = result.error;
                  const errorCode = result.error.code || result.error.status || 'NO_CODE';
                  const errorMessage = result.error.message || result.error.toString() || 'Unknown error';
                  const errorDetails = result.error.details || result.error.hint || null;
                  const timestamp = new Date().toISOString();
                  
                  console.error('[ReviewList] ‚ùå Supabase query returned error:', {
                    timestamp,
                    attempt: attempt + 1,
                    totalAttempts: maxRetries + 1,
                    errorCode,
                    errorMessage,
                    errorDetails,
                    error: result.error,
                    placeId,
                    isRLSError: errorCode === 'PGRST301' || errorMessage?.includes('RLS') || errorMessage?.includes('permission'),
                    isNetworkError: errorMessage?.includes('network') || errorMessage?.includes('fetch') || errorMessage?.includes('timeout')
                  });
                  
                  // Retry hanya untuk timeout atau network errors, bukan untuk RLS errors
                  const shouldRetry = attempt < maxRetries && (
                    errorMessage?.includes('timeout') ||
                    errorMessage?.includes('network') ||
                    errorMessage?.includes('fetch')
                  );
                  
                  if (shouldRetry) {
                    const delay = Math.min(1000 * Math.pow(2, attempt), 5000); // Exponential backoff, max 5 detik
                    console.warn(`[ReviewList] ‚è≥ Attempt ${attempt + 1} failed, retrying in ${delay}ms...`, {
                      timestamp,
                      errorMessage,
                      nextAttempt: attempt + 2,
                      delayMs: delay,
                      placeId
                    });
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue;
                  } else {
                    // Don't retry for RLS or other non-retryable errors
                    console.warn('[ReviewList] ‚ö†Ô∏è Not retrying - non-retryable error:', {
                      timestamp,
                      errorCode,
                      errorMessage,
                      reason: 'RLS or other non-retryable error',
                      placeId
                    });
                    break;
                  }
                } else {
                  // Success!
                  data = result.data;
                  fetchError = null;
                  const dataCount = data?.length || 0;
                  const timestamp = new Date().toISOString();
                  
                  if (attempt > 0) {
                    console.log(`[ReviewList] ‚úÖ Success after ${attempt + 1} attempts`);
                  }
                  
                  console.log('[ReviewList] ‚úÖ Supabase fetch SUCCESS:', {
                    timestamp,
                    attempt: attempt + 1,
                    totalAttempts: maxRetries + 1,
                    dataCount,
                    placeId,
                    hasData: dataCount > 0,
                    preserveExisting
                  });
                  
                  break;
                }
              } catch (raceError) {
                // Clear timeout if still exists
                if (timeoutId) {
                  clearTimeout(timeoutId);
                  timeoutId = null;
                }
                
                // Check if request was aborted
                if (abortController.signal.aborted) {
                  console.log('[ReviewList] ‚ö†Ô∏è Request aborted during retry:', {
                    timestamp: new Date().toISOString(),
                    attempt: attempt + 1,
                    placeId
                  });
                  break;
                }
                
                lastAttemptError = raceError;
                const timeoutMessage = raceError?.message || raceError?.toString() || 'Request timeout or failed';
                const errorType = raceError?.name || 'UnknownError';
                const timestamp = new Date().toISOString();
                const isTimeoutError = timeoutMessage.includes('timeout');
                
                console.error('[ReviewList] ‚ùå Fetch attempt failed:', {
                  timestamp,
                  attempt: attempt + 1,
                  totalAttempts: maxRetries + 1,
                  errorType,
                  errorMessage: timeoutMessage,
                  errorStack: raceError?.stack,
                  placeId,
                  isTimeoutError,
                  willRetry: attempt < maxRetries && isTimeoutError && !abortController.signal.aborted
                });
                
                // Retry hanya untuk timeout errors
                const shouldRetry = attempt < maxRetries && isTimeoutError && !abortController.signal.aborted;
                
                if (shouldRetry) {
                  const delay = Math.min(1000 * Math.pow(2, attempt), 5000); // Exponential backoff, max 5 detik
                  console.warn(`[ReviewList] ‚è≥ Attempt ${attempt + 1} timed out, retrying in ${delay}ms...`, {
                    timestamp: new Date().toISOString(),
                    nextAttempt: attempt + 2,
                    delayMs: delay,
                    placeId
                  });
                  await new Promise(resolve => setTimeout(resolve, delay));
                  continue;
                } else {
                  // Final attempt failed or non-retryable error
                  const finalTimestamp = new Date().toISOString();
                  console.warn('[ReviewList] ‚ùå Supabase request failed or timed out (FINAL):', {
                    timestamp: finalTimestamp,
                    message: timeoutMessage,
                    errorType: errorType,
                    error: raceError,
                    errorStack: raceError?.stack,
                    placeId: placeId,
                    totalAttempts: attempt + 1,
                    maxRetries: maxRetries,
                    timeout: baseTimeout
                  });
                  
                  // Track timeout
                  if (timeoutMessage.includes('timeout')) {
                    trackTimeout(`/rest/v1/reviews?place_id=eq.${placeId}`, baseTimeout, {
                      placeId,
                      attempts: attempt + 1
                    });
                  } else {
                    trackError(raceError, { placeId, attempts: attempt + 1, action: 'fetchReviews' });
                  }
                  
                  fetchError = raceError;
                  break;
                }
              }
            }
            
            // Log final result
            if (fetchError && lastAttemptError) {
              fetchError = lastAttemptError;
            }
            
            // Log hasil fetch untuk debugging
            console.log('[ReviewList] Supabase fetch result:', {
              dataCount: data?.length || 0,
              hasError: !!fetchError,
              error: fetchError?.message || fetchError?.toString(),
              errorCode: fetchError?.code,
              errorDetails: fetchError?.details
            });

            if (fetchError) {
              // Extract error message dengan lebih baik
              const errorMessage = fetchError.message || fetchError.toString() || 'Unknown error';
              const errorCode = fetchError.code || 'NO_CODE';
              const errorDetails = fetchError.details || null;
              const errorHint = fetchError.hint || null;
              
              // Log error dengan detail untuk debugging RLS issues
              const timestamp = new Date().toISOString();
              console.error('[ReviewList] ‚ùå Error fetching from Supabase:', {
                timestamp,
                errorType: fetchError?.name || 'SupabaseError',
                message: errorMessage,
                code: errorCode,
                details: errorDetails,
                hint: errorHint,
                errorStack: fetchError?.stack,
                placeId: placeId,
                preserveExisting,
                fullError: fetchError // Include full error untuk debugging
              });
              
              // Check if it's RLS error (401/403)
              if (errorCode === 'PGRST301' || errorMessage.includes('401') || errorMessage.includes('403')) {
                console.error('[ReviewList] ‚ö†Ô∏è RLS POLICY ERROR - Guest mungkin tidak bisa membaca reviews. Cek RLS policy di Supabase!');
                console.error('[ReviewList] Pastikan policy "Reviews viewable by everyone" menggunakan USING (true)');
              }
              
              // Check if it's timeout error
              if (errorMessage.includes('timeout')) {
                console.error('');
                console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.error('üî¥ TIMEOUT ERROR SETELAH 20 DETIK');
                console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.error('');
                console.error('üìã LANGKAH DEBUGGING:');
                console.error('');
                console.error('1. VERIFIKASI INDEX sudah dibuat:');
                console.error('   Buka Supabase SQL Editor dan jalankan:');
                console.error('   SELECT indexname FROM pg_indexes WHERE tablename = \'reviews\';');
                console.error('');
                console.error('   Harus ada: idx_reviews_place_created');
                console.error('');
                console.error('2. TEST PERFORMA QUERY:');
                console.error('   EXPLAIN ANALYZE');
                console.error('   SELECT * FROM reviews WHERE place_id = \'' + placeId + '\'');
                console.error('   ORDER BY created_at DESC LIMIT 25;');
                console.error('');
                console.error('   Execution Time harus < 100ms');
                console.error('');
                console.error('3. CEK RLS POLICY:');
                console.error('   SELECT policyname, qual FROM pg_policies WHERE tablename = \'reviews\';');
                console.error('');
                console.error('   Policy untuk SELECT harus simple: USING (true)');
                console.error('');
                console.error('4. JIKA MASIH TIMEOUT:');
                console.error('   - Cek network connection (gunakan 4G/WiFi yang stabil)');
                console.error('   - Cek Supabase Dashboard ‚Üí Database ‚Üí Performance');
                console.error('   - Restart Supabase project jika CPU usage tinggi');
                console.error('');
                console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.error('');
              }
              
              // Don't throw - continue without reviews
            } else if (data) {
              // Fetch profiles separately untuk reviews yang berhasil di-fetch
              // OPTIMIZED: Fetch profiles dengan timeout terpisah dan limit
              // Ini lebih cepat daripada join di query utama dan prevent timeout
              const userIds = [...new Set(data.map(r => r.user_id).filter(Boolean))];
              let profilesMap = {};
              
              if (userIds.length > 0) {
                const profileStartTime = Date.now();
                
                try {
                  // OPTIMIZED: Fetch profiles dengan timeout lebih pendek (5 detik)
                  // Jika profile fetch timeout, continue tanpa profiles (non-critical)
                  const profilePromise = supabase
                    .from('profiles')
                    .select('id, username, avatar_url, full_name')
                    .in('id', userIds)
                    .limit(100); // Limit untuk prevent timeout
                  
                  const profileTimeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Profile fetch timeout')), 5000);
                  });
                  
                  const profileResult = await Promise.race([profilePromise, profileTimeoutPromise]);
                  
                  if (profileResult?.data) {
                    profilesMap = profileResult.data.reduce((acc, p) => {
                      acc[p.id] = p;
                      return acc;
                    }, {});
                    
                    const profileDuration = Date.now() - profileStartTime;
                    console.log(`[ReviewList] ‚ö° Profiles fetched in ${profileDuration}ms (${profileResult.data.length} profiles)`);
                  }
                } catch (profileError) {
                  const profileDuration = Date.now() - profileStartTime;
                  console.warn(`[ReviewList] ‚ö†Ô∏è Error fetching profiles after ${profileDuration}ms (non-critical):`, profileError?.message || profileError);
                  // Continue without profiles - reviews tetap bisa ditampilkan
                  // Profiles akan di-fetch lazy jika diperlukan
                }
              }
              
              // Map reviews dengan format yang konsisten
              const mappedReviews = data.map(r => {
                const profile = profilesMap[r.user_id] || null;
                return {
                  ...r,
                  source: 'supabase',
                  // Photos dan replies akan di-fetch setelah ini
                  photos: [],
                  replies: [],
                  // Map profile data
                  profiles: profile,
                  // Ensure author_name untuk backward compatibility
                  author_name: profile?.username || profile?.full_name || 'Anonim'
                };
              });
              
              // Fetch photos dan replies untuk semua reviews dalam batch
              const reviewIds = mappedReviews.map(r => r.id);
              
              // Fetch photos untuk semua reviews
              let photosMap = {};
              if (reviewIds.length > 0) {
                try {
                  const photosStartTime = Date.now();
                  const { data: photosData } = await supabase
                    .from('review_photos')
                    .select('id, review_id, photo_url')
                    .in('review_id', reviewIds)
                    .order('created_at', { ascending: true });
                  
                  if (photosData) {
                    // Group photos by review_id
                    photosMap = photosData.reduce((acc, photo) => {
                      if (!acc[photo.review_id]) {
                        acc[photo.review_id] = [];
                      }
                      acc[photo.review_id].push(photo);
                      return acc;
                    }, {});
                    
                    const photosDuration = Date.now() - photosStartTime;
                    console.log(`[ReviewList] ‚ö° Photos fetched in ${photosDuration}ms (${photosData.length} photos for ${Object.keys(photosMap).length} reviews)`);
                  }
                } catch (photosError) {
                  console.warn('[ReviewList] ‚ö†Ô∏è Error fetching photos (non-critical):', photosError?.message || photosError);
                }
              }
              
              // Fetch replies untuk semua reviews
              let repliesMap = {};
              if (reviewIds.length > 0) {
                try {
                  const repliesStartTime = Date.now();
                  const { data: repliesData } = await supabase
                    .from('review_replies')
                    .select(`
                      id,
                      review_id,
                      user_id,
                      text,
                      created_at,
                      profiles:user_id (username, avatar_url, full_name)
                    `)
                    .in('review_id', reviewIds)
                    .order('created_at', { ascending: true });
                  
                  if (repliesData) {
                    // Group replies by review_id
                    repliesMap = repliesData.reduce((acc, reply) => {
                      if (!acc[reply.review_id]) {
                        acc[reply.review_id] = [];
                      }
                      acc[reply.review_id].push(reply);
                      return acc;
                    }, {});
                    
                    const repliesDuration = Date.now() - repliesStartTime;
                    console.log(`[ReviewList] ‚ö° Replies fetched in ${repliesDuration}ms (${repliesData.length} replies for ${Object.keys(repliesMap).length} reviews)`);
                  }
                } catch (repliesError) {
                  console.warn('[ReviewList] ‚ö†Ô∏è Error fetching replies (non-critical):', repliesError?.message || repliesError);
                }
              }
              
              // Merge photos dan replies ke reviews
              const reviewsWithPhotosAndReplies = mappedReviews.map(review => ({
                ...review,
                photos: photosMap[review.id] || [],
                replies: repliesMap[review.id] || []
              }));
              
              supabaseReviews = reviewsWithPhotosAndReplies;
              
              // Merge dengan existing reviews jika preserveExisting = true
              if (preserveExisting) {
                setReviews(prev => {
                  // Merge: keep existing reviews yang tidak ada di fetch baru, add new ones
                  const existingIds = new Set(prev.map(r => r.id));
                  const newReviews = mappedReviews.filter(r => !existingIds.has(r.id));
                  const updatedReviews = prev.map(existing => {
                    const updated = mappedReviews.find(r => r.id === existing.id);
                    return updated || existing; // Use updated version if exists, otherwise keep existing
                  });
                  return [...newReviews, ...updatedReviews].sort((a, b) => {
                    // Sort by created_at descending
                    const dateA = new Date(a.created_at || 0);
                    const dateB = new Date(b.created_at || 0);
                    return dateB - dateA;
                  });
                });
              } else {
                setReviews(mappedReviews);
              }
              
              lastFetchTimeRef.current = Date.now();
              console.log('[ReviewList] Set reviews from Supabase:', mappedReviews.length, 'Preserve existing:', preserveExisting);
              console.log('[ReviewList] Sample review:', mappedReviews[0] ? {
                id: mappedReviews[0].id,
                text: mappedReviews[0].text?.substring(0, 50),
                username: mappedReviews[0].profiles?.username,
                rating: mappedReviews[0].rating
              } : 'No reviews');
            } else {
              console.warn('[ReviewList] Supabase returned no data and no error');
              // Don't clear reviews if preserveExisting = true
              // Keep existing reviews even if no new data
              if (!preserveExisting && supabaseReviews.length === 0) {
                setReviews([]);
              } else if (supabaseReviews.length > 0) {
                // We have reviews from previous attempts - keep them
                console.log('[ReviewList] Keeping existing reviews:', supabaseReviews.length);
              }
            }
          } catch (supabaseError) {
            const timestamp = new Date().toISOString();
            const errorType = supabaseError?.name || 'SupabaseFetchException';
            const errorMessage = supabaseError?.message || supabaseError?.toString() || 'Unknown error';
            const errorCode = supabaseError?.code || supabaseError?.status || 'NO_CODE';
            const errorDetails = supabaseError?.details || supabaseError?.hint || null;
            
            console.error('[ReviewList] ‚ùå Supabase fetch EXCEPTION:', {
              timestamp,
              errorType,
              errorMessage,
              errorCode,
              errorDetails,
              errorStack: supabaseError?.stack,
              placeId,
              preserveExisting,
              existingReviewsCount: reviewsLengthRef.current,
              supabaseReviewsCount: supabaseReviews.length,
              isAborted: abortController?.signal?.aborted || false
            });
            
            // Track error untuk debugging
            trackError(supabaseError, { placeId, action: 'fetchReviews', stage: 'supabaseFetch' });
            
            // CRITICAL: Don't clear reviews on error - keep existing reviews if any
            // This ensures reviews are still displayed even if fetch fails
            // Only clear if this is initial load and we have no reviews yet
            if (!preserveExisting && supabaseReviews.length === 0 && reviewsLengthRef.current === 0) {
              // Only clear if we truly have no data at all
              console.warn('[ReviewList] ‚ö†Ô∏è No reviews available after error - clearing state:', {
                timestamp,
                reason: 'No existing reviews and fetch failed',
                placeId
              });
              setReviews([]);
            } else {
              console.log('[ReviewList] ‚úÖ Keeping existing reviews despite error:', {
                timestamp,
                existingReviewsCount: reviewsLengthRef.current,
                supabaseReviewsCount: supabaseReviews.length,
                preserveExisting,
                placeId,
                note: 'UI will continue to show existing reviews'
              });
            }
          }
        } else {
          console.log('[ReviewList] Supabase not configured or not available');
          setReviews([]);
        }
        
        // Ensure we have data before setting loading to false
        if (supabaseReviews.length === 0) {
          console.log('[ReviewList] No reviews found for place_id:', placeId);
        }

      } catch (err) {
        // Extract error message dengan lebih baik
        const errorMessage = err?.message || err?.toString() || 'Unknown error';
        const errorStack = err?.stack || null;
        
        console.error('[ReviewList] Error loading reviews:', {
          message: errorMessage,
          stack: errorStack,
          error: err,
          placeId: placeId
        });
        
        // Track error untuk debugging
        trackError(err, { placeId, action: 'loadReviews', stage: 'general' });
        
        setError('Gagal memuat review');
        // CRITICAL: Don't clear reviews on error if preserveExisting = true
        // Keep existing reviews even if load fails
        if (!preserveExisting) {
          setReviews([]);
        }
      } finally {
        // Clear pending request flag
        pendingRequestRef.current = false;
        setLoading(false);
        // Update lastFetchTime setelah fetch selesai
        lastFetchTimeRef.current = Date.now();
        // Use setTimeout to log after state update
        setTimeout(() => {
          console.log('[ReviewList] Loading completed. Total reviews in state:', reviews.length);
        }, 100);
      }
    };

    // Initial load - clear reviews
    // Use a flag to prevent duplicate calls
    let isMounted = true;
    
    // Add small delay untuk memastikan semua state sudah siap setelah refresh
    const initialLoad = async () => {
      // Delay kecil untuk memastikan component benar-benar mounted dan state siap
      // Lebih lama untuk force refresh (refreshTrigger > 0) untuk memastikan cleanup selesai
      const delay = refreshTrigger > 0 ? 200 : 100;
      await new Promise(resolve => setTimeout(resolve, delay));
      
      if (isMounted && !pendingRequestRef.current && placeId) {
        const isInitializing = isInitializingRef.current;
        console.log('[ReviewList] Starting initial load...', { refreshTrigger, isInitializing });
        isInitializingRef.current = false; // Mark as no longer initializing
        await loadReviews(false);
      } else {
        console.log('[ReviewList] Skipping initial load:', { isMounted, pending: pendingRequestRef.current, placeId });
      }
    };
    
    initialLoad();
    
    // Cleanup function
    return () => {
      isMounted = false;
      console.log('[ReviewList] useEffect cleanup - aborting requests');
      // Abort any pending request on unmount
      if (abortControllerRef.current) {
        try {
          abortControllerRef.current.abort();
        } catch (e) {
          console.warn('[ReviewList] Error aborting in cleanup:', e);
        }
        abortControllerRef.current = null;
      }
      pendingRequestRef.current = false;
    };
    
    // NOTE: visibilitychange listener dihapus karena terlalu agresif
    // Ini menyebabkan review hilang saat user tidak melakukan apa-apa
    // Jika perlu refresh, user bisa manual refresh page
    // reviews.length tidak perlu di dependencies karena kita menggunakan reviewsLengthRef untuk check
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [placeId, refreshTrigger]); // Re-fetch when placeId changes OR refreshTrigger changes

  // Handle new review added - OPTIMISTIC UI UPDATE
  useEffect(() => {
    if (newReview && newReview.id) {
      // Ensure review has profile data and source
      const newReviewWithSource = {
        ...newReview,
        source: 'supabase',
        photos: newReview.photos || [],
        replies: newReview.replies || [],
        // Ensure author_name untuk backward compatibility
        author_name: newReview.profiles?.username || newReview.profiles?.full_name || 'Anonim'
      };
      
      console.log('[ReviewList] ‚úÖ New review added (optimistic update):', {
        id: newReviewWithSource.id,
        username: newReviewWithSource.profiles?.username || 'No username',
        hasProfile: !!newReviewWithSource.profiles,
        user_id: newReviewWithSource.user_id
      });
      
      // OPTIMISTIC UI: Add review immediately to UI (instant feedback)
      setLoading(false);
      
      // Check if review already exists (prevent duplicates)
      setReviews(prev => {
        const exists = prev.some(r => r.id === newReviewWithSource.id);
        if (exists) {
          console.log('[ReviewList] Review already exists, updating instead');
          // Update existing review instead of adding duplicate
          return prev.map(r => r.id === newReviewWithSource.id ? newReviewWithSource : r);
        }
        // Add new review to the top of the list
        console.log('[ReviewList] Adding new review to list. Total before:', prev.length);
        const updated = [newReviewWithSource, ...prev];
        console.log('[ReviewList] Total after:', updated.length);
        return updated;
      });
      
      // Smart refetch: Wait a bit for Supabase to commit, then refresh to sync
      // This ensures we have the latest data from database
      setTimeout(() => {
        console.log('[ReviewList] Triggering smart refetch after new review (500ms delay)');
        pendingRequestRef.current = false;
        if (abortControllerRef.current) {
          try {
            abortControllerRef.current.abort();
          } catch (e) {
            console.warn('[ReviewList] Error aborting before refetch:', e);
          }
          abortControllerRef.current = null;
        }
        setRefreshTrigger(prev => prev + 1);
      }, 500); // 500ms delay untuk memastikan Supabase sudah commit transaction
    }
  }, [newReview]);
  
  // Handle review delete
  const handleDelete = (reviewId) => {
    setReviews(prev => prev.filter(r => r.id !== reviewId));
  };

  // Handle review update - force refresh setelah edit
  const handleUpdate = (updatedReview) => {
    console.log('[ReviewList] Review updated, refreshing data...', updatedReview.id);
    
    // OPTIMISTIC UI: Update local state immediately untuk instant feedback
    setReviews(prev => prev.map(r => 
      r.id === updatedReview.id ? { ...r, ...updatedReview } : r
    ));
    
    // CRITICAL: Reset pending request flag sebelum trigger refresh
    // Ini memastikan refresh bisa berjalan meskipun ada request sebelumnya
    pendingRequestRef.current = false;
    
    // Abort any pending request sebelum refresh
    if (abortControllerRef.current) {
      try {
        abortControllerRef.current.abort();
      } catch (e) {
        console.warn('[ReviewList] Error aborting before refresh:', e);
      }
      abortControllerRef.current = null;
    }
    
    // Smart refetch: Wait a bit for Supabase to commit the transaction
    // Then trigger refresh to get latest data from database
    setTimeout(() => {
      console.log('[ReviewList] Triggering smart refetch after update (500ms delay for DB commit)');
      setRefreshTrigger(prev => prev + 1);
    }, 500); // 500ms delay untuk memastikan Supabase sudah commit transaction
    
    console.log('[ReviewList] ‚úÖ Optimistic update applied, refresh scheduled');
  };

  // Calculate stats (always use all reviews, not filtered)
  const stats = {
    total: reviews.length,
    average: reviews.length > 0 
      ? (reviews.reduce((acc, r) => acc + (r.rating || 0), 0) / reviews.length).toFixed(1)
      : 0,
    distribution: [5, 4, 3, 2, 1].map(rating => ({
      rating,
      count: reviews.filter(r => r.rating === rating).length,
      percentage: reviews.length > 0 
        ? Math.round((reviews.filter(r => r.rating === rating).length / reviews.length) * 100)
        : 0
    }))
  };

  // OPTIMISTIC UI: Tampilkan reviews yang sudah ada meski sedang loading
  // Ini mencegah skeleton muncul jika reviews sudah ada di state
  const shouldShowSkeleton = loading && reviews.length === 0;
  
  if (shouldShowSkeleton) {
    return (
      <div className="space-y-4">
        {[1, 2, 3].map(i => (
          <div key={i} className="bg-white dark:bg-zinc-800 rounded-xl p-5 animate-pulse">
            <div className="flex items-center gap-3 mb-3">
              <div className="w-10 h-10 rounded-full bg-gray-200 dark:bg-zinc-700"></div>
              <div className="flex-1">
                <div className="h-4 bg-gray-200 dark:bg-zinc-700 rounded w-24 mb-2"></div>
                <div className="h-3 bg-gray-200 dark:bg-zinc-700 rounded w-20"></div>
              </div>
            </div>
            <div className="h-4 bg-gray-200 dark:bg-zinc-700 rounded w-full mb-2"></div>
            <div className="h-4 bg-gray-200 dark:bg-zinc-700 rounded w-3/4"></div>
          </div>
        ))}
      </div>
    );
  }

  return (
    <div>

      {/* Stats Header */}
      {reviews.length > 0 && (
        <div className="bg-white dark:bg-zinc-800 rounded-xl p-5 mb-6 border border-gray-200 dark:border-zinc-700">
          <div className="flex flex-col sm:flex-row sm:items-center gap-6">
            {/* Average Rating */}
            <div className="text-center sm:text-left">
              <div className="text-4xl font-bold text-gray-900 dark:text-white">
                {stats.average}
              </div>
              <div className="flex justify-center sm:justify-start mt-1">
                {[1, 2, 3, 4, 5].map((star) => (
                  <svg
                    key={star}
                    className={`w-5 h-5 ${
                      star <= Math.round(parseFloat(stats.average))
                        ? 'text-amber-400 fill-current'
                        : 'text-gray-300 dark:text-zinc-600'
                    }`}
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={1.5}
                      d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"
                    />
                  </svg>
                ))}
              </div>
              <div className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                {stats.total} review
              </div>
            </div>

            {/* Rating Distribution */}
            <div className="flex-1 space-y-1.5">
              {stats.distribution.map(({ rating, count, percentage }) => (
                <div key={rating} className="flex items-center gap-2 text-sm">
                  <span className="w-3 text-gray-600 dark:text-gray-400">{rating}</span>
                  <svg className="w-4 h-4 text-amber-400 fill-current" viewBox="0 0 24 24">
                    <path d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" />
                  </svg>
                  <div className="flex-1 h-2 bg-gray-200 dark:bg-zinc-700 rounded-full overflow-hidden">
                    <div 
                      className="h-full bg-amber-400 rounded-full transition-all duration-500"
                      style={{ width: `${percentage}%` }}
                    />
                  </div>
                  <span className="w-8 text-right text-gray-500 dark:text-gray-400">{count}</span>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Reviews List */}
      {reviews.length === 0 ? (
        <div className="text-center py-12 bg-gray-50 dark:bg-zinc-800/50 rounded-xl border border-gray-200 dark:border-zinc-700">
          <svg className="w-16 h-16 mx-auto text-gray-400 dark:text-gray-600 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
          </svg>
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">
            Belum ada review
          </h3>
          <p className="text-gray-600 dark:text-gray-400">
            Jadilah yang pertama memberikan review!
          </p>
        </div>
      ) : (
        <div className="space-y-4">
          {reviews.map((review) => (
            <ReviewCard
              key={review.id}
              review={review}
              onDelete={handleDelete}
              onUpdate={handleUpdate}
              showSourceBadge={false}
            />
          ))}
        </div>
      )}

      {/* Error Message */}
      {/* Error message dengan solusi debugging */}
      {error && (
        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-xl p-6 mb-6">
          <div className="flex items-start gap-3">
            <div className="flex-shrink-0 w-10 h-10 bg-red-100 dark:bg-red-900/30 rounded-full flex items-center justify-center">
              <svg className="w-6 h-6 text-red-600 dark:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div className="flex-1">
              <h3 className="text-lg font-semibold text-red-900 dark:text-red-300 mb-2">
                {error}
              </h3>
              {error.includes('timeout') && (
                <div className="space-y-3 text-sm text-red-800 dark:text-red-400 mt-3">
                  <div className="bg-red-100 dark:bg-red-900/40 p-4 rounded-lg">
                    <p className="font-bold mb-2">üîç Langkah Debugging:</p>
                    
                    <div className="space-y-3">
                      <div>
                        <p className="font-semibold mb-1">1Ô∏è‚É£ Verifikasi Index</p>
                        <p className="text-xs mb-1">Jalankan di Supabase SQL Editor:</p>
                        <pre className="bg-white dark:bg-red-950 p-2 rounded text-xs overflow-x-auto font-mono">
{`SELECT indexname FROM pg_indexes 
WHERE tablename = 'reviews';`}
                        </pre>
                        <p className="text-xs mt-1 italic">‚úÖ Harus ada: <code className="bg-white dark:bg-red-950 px-1 rounded">idx_reviews_place_created</code></p>
                      </div>

                      <div>
                        <p className="font-semibold mb-1">2Ô∏è‚É£ Test Performa Query</p>
                        <p className="text-xs mb-1">Jalankan di Supabase SQL Editor:</p>
                        <pre className="bg-white dark:bg-red-950 p-2 rounded text-xs overflow-x-auto font-mono">
{`EXPLAIN ANALYZE
SELECT * FROM reviews 
WHERE place_id = '${placeId}' 
ORDER BY created_at DESC LIMIT 25;`}
                        </pre>
                        <p className="text-xs mt-1 italic">‚úÖ Execution Time harus &lt; 100ms</p>
                        <p className="text-xs italic">‚úÖ Harus pakai "Index Scan", BUKAN "Seq Scan"</p>
                      </div>

                      <div>
                        <p className="font-semibold mb-1">3Ô∏è‚É£ Cek RLS Policy</p>
                        <p className="text-xs mb-1">Jalankan di Supabase SQL Editor:</p>
                        <pre className="bg-white dark:bg-red-950 p-2 rounded text-xs overflow-x-auto font-mono">
{`SELECT policyname, qual 
FROM pg_policies 
WHERE tablename = 'reviews';`}
                        </pre>
                        <p className="text-xs mt-1 italic">‚úÖ Policy SELECT harus simple: <code className="bg-white dark:bg-red-950 px-1 rounded">USING (true)</code></p>
                      </div>

                      <div className="border-t border-red-300 dark:border-red-700 pt-2 mt-2">
                        <p className="font-semibold mb-1">üîß Jika Masih Timeout:</p>
                        <ul className="text-xs space-y-1 ml-4 list-disc">
                          <li>Cek koneksi internet (gunakan WiFi/4G yang stabil)</li>
                          <li>Buka Supabase Dashboard ‚Üí Database ‚Üí Performance</li>
                          <li>Cek CPU/Memory usage (jika tinggi, restart project)</li>
                          <li>Lihat file <code className="bg-white dark:bg-red-950 px-1 rounded">VERIFY_INDEX.sql</code> dan <code className="bg-white dark:bg-red-950 px-1 rounded">FIX_RLS_POLICY.sql</code></li>
                        </ul>
                      </div>
                    </div>
                  </div>
                </div>
              )}
              <div className="flex gap-2 mt-4">
                <button
                  onClick={() => {
                    setError(null);
                    setRefreshTrigger(prev => prev + 1);
                  }}
                  className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-medium rounded-lg transition-colors inline-flex items-center gap-2"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                  Coba Lagi
                </button>
                <button
                  onClick={() => {
                    window.open('https://supabase.com/dashboard/project/_/sql/new', '_blank');
                  }}
                  className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-medium rounded-lg transition-colors inline-flex items-center gap-2"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                  </svg>
                  Buka SQL Editor
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ReviewList;
